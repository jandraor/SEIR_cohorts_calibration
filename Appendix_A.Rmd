---
title: "Appendix A"
output:
  pdf_document: 
    number_sections: true
  html_notebook: default
header-includes:
  - \usepackage{booktabs}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE,
                      cache = FALSE)

## WORKAROUND: https://github.com/rstudio/rstudio/issues/6692
## Revert to 'sequential' setup of PSOCK cluster in RStudio Console on macOS and R 4.0.0
if (Sys.getenv("RSTUDIO") == "1" && !nzchar(Sys.getenv("RSTUDIO_TERM")) && 
    Sys.info()["sysname"] == "Darwin" && getRversion() == "4.0.0") {
  parallel:::setDefaultClusterOptions(setup_strategy = "sequential")
}

library(bayesplot)
library(cmdstanr)
library(deSolve)
library(dplyr)
library(GGally)
library(ggalt)
library(ggplot2)
library(ggpubr)
library(ggsci)
library(gridExtra)
library(kableExtra)
library(MLmetrics)
library(Metrics)
library(parallel)
library(purrr)
library(readsdr) # devtools::install_github("jandraor/readsdr")
library(readr)
library(rethinking)
library(rstan)
library(socialmixr)
library(scales)
library(stringr)
library(tictoc)
library(tidyr)

source("./R/graphs.R")
source("./R/stan_utils.R")
source("./R/NMS_utils.R")
source("./R/optimise_SEIR.R")
source("./R/summaries_utils.R")
source("./R/summarise_results.R")
source("./R/Metrics.R")
```


# Synthetic data

## Parameters

## Average contacts per age group

```{r, fig.height = 4.5, fig.width = 5, fig.align= "center"}
source("./R/synthetic_params.R")

pop_size   <- 1e4
age_limits <- c(0, 5, 15, 45)

output_sp <- produce_synthetic_params(pop_size, age_limits)
pop_df    <- output_sp$population
pop_size  <- sum(pop_df$population)
output_sp$g_original_contacts
```

##  Aggregated average contacts per age group - Corrected for reciprocity

```{r, fig.height = 2.5, fig.width = 3, fig.align= "center"}
output_sp$g_c_M_matrix
```



##  Synthetic WAIFW & normalised age-specific contact rate matrix (K)

```{r g_synWAIFW, fig.height = 2.5, fig.width = 5, fig.align= "center"}
grey_actual_K <- output_sp$g_K_matrix +
  scale_fill_gradient(low = "#D3D3D3", high = "#696969") +
  labs(subtitle = "Actual K")

actual_K <- output_sp$K_matrix

ggarrange(output_sp$g_syn_WAIFW, output_sp$g_K_matrix)
```

## Synthetic incidence from 4-cohort SEIR

```{r, fig.height = 4, fig.align= 'center'}
source("./R/synthetic_incidence.R")

stop_time          <- 50
reporting_fraction <- 0.8
seed               <- 18061986
output_gsi         <- generate_synthetic_incidence(output_sp, stop_time,
                                                   reporting_fraction, seed)
length_data        <- stop_time
data_list_prf      <- output_gsi$data_list$prf
data_list_und      <- output_gsi$data_list$und
output_gsi$g_incidences
```

## Reporting scenarios

```{r, fig.height = 4, fig.align= 'center'}

prf_df <- output_gsi$tidy_list$prf
und_df <- output_gsi$tidy_list$und

inc_df <- bind_rows(prf_df, und_df)

g_timeseries <- ggplot(inc_df, aes(x = time, y = y)) +
  geom_col(aes(group = Scenario, fill = Scenario, linetype = Scenario),
           alpha = 0.75) +
  scale_fill_manual(values = c("#a0e3b7", "#20502e")) +
  scale_y_continuous(labels =  comma) +
  theme_test() +
  facet_wrap(~cohort) +
  theme(legend.position = "bottom") +
  labs(x = "Days since first case detected", y = "Incidence [Cases / Day]") 

print(g_timeseries)

ggsave("./plots/incidence_reports.png", dpi = "print", height = 5, width = 8)
```


\newpage
# Calibration

## Matrix structures

### Feasible permutations

If we assume that there are exactly four separate parameters in a WAIFW square 
matrix of size four, equation 1 defines the number of possible permutations. The
first term represents the entire universe of permutations in the the square
matrix with up to four separate parameters. The second term removes the permutations with
up to three parameters. Nevetheless, this operation double-counts a set permutations with
common elements. Therefore, the last two operators restore those elements.

\begin{equation}
 4 ^{16} \binom{4}{4} - 3 ^{16} \binom{4}{3} + 2^{16} \binom{4}{2} - 1^{16} \binom{4}{1}
\end{equation}

### K matrices for testing

```{r, fig.height = 6, fig.width = 5, fig.align = 'center'}
age_groups <- c("00-04", "05-14", "15-44", "45+")
matrices   <- c("Symmetric", paste0("Matrix ", LETTERS[1:4]))
m_index    <- c(LETTERS[1:4], "sym") # Matrix index

# Kannan & Farrington (2005)
conceptual_matrix_A <- c("k11", "k11", "k33", "k44",
                         "k11", "k22", "k33", "k44",
                         "k33", "k33", "k33", "k44",
                         "k44", "k44", "k44", "k44")

conceptual_matrix_B <- c("k11", "k11", "k11", "k11",
                         "k11", "k22", "k22", "k22",
                         "k11", "k22", "k33", "k44",
                         "k11", "k22", "k44", "k44")

conceptual_matrix_C <- c("k11", "k22", "k13", "k22",
                         "k22", "k22", "k22", "k22",
                         "k13", "k22", "k44", "k44",
                         "k22", "k22", "k44", "k44")

conceptual_matrix_D <- c("k11", "k44", "k44", "k44",
                         "k44", "k22", "k44", "k44",
                         "k44", "k44", "k33", "k44",
                         "k44", "k44", "k44", "k44")

# Symmetrical matrix
conceptual_matrix_sym <- c("k11", "k12", "k13", "k14",
                           "k12", "k22", "k23", "k24",
                           "k13", "k23", "k33", "k34",
                           "k14", "k24", "k34", "k44")

# Conceptual matrix list
cm_list <- list(conceptual_matrix_A, conceptual_matrix_B,
                conceptual_matrix_C, conceptual_matrix_D,
                conceptual_matrix_sym)

names(cm_list) <- m_index



titles <- c(
  "Matrix A - 4 parameters",
  "Matrix B - 4 parameters",
  "Matrix C - 4 parameters",
  "Matrix D - 4 parameters",
  "Symmetric matrix - 10 parameters")

g_cm <- map2(cm_list, titles, function(cm, gtitle) {
  contact_matrix <- matrix(cm, nrow = 4)
  colnames(contact_matrix) <- rownames(contact_matrix) <- age_groups
  WAIFW_df    <- melt(contact_matrix)
  
  colours <- pal_jco()(length(unique(cm)))
  
  g_matrix <- ggplot(data = WAIFW_df, 
       aes(x = Var1, y = ordered(Var2, levels = rev(sort(unique(Var2)))))) + 
    geom_tile(aes(fill = value), colour = "black") +
    geom_text(aes(label = value), colour = "white", size = 5)
    
  g_matrix <- g_matrix + scale_fill_manual(values = colours) 
  
    
  g_matrix <- g_matrix +
    theme_minimal() + 
    labs(y ="", x = "", subtitle = gtitle) +
    theme(legend.position = "none")
})


g_matrices <- grid.arrange(g_cm[[1]], g_cm[[2]], g_cm[[3]], g_cm[[4]], g_cm[[5]], ncol = 2)

ggsave("./plots/g_matrices.png", dpi = "print", height = 5, width = 5, 
       plot = g_matrices)
```

\newpage

## Perfect information

### By optimisation

```{r}
tic.clearlog()

g_options <- list(stripSize = 4,
                  legendPosition = "bottom",
                  axisTextXSize = 4,
                  axisTextYSize = 4,
                  axisTitleSize = 5,
                  legendSize    = 4,
                  legendBoxMargin = FALSE,
                  titleSize = 6)

sim_specs <- list(start_time = 0,
                  stop_time  = stop_time ,
                  step_size  = 1 / 32,
                  integ_method = "rk4",
                  stock_list = output_gsi$stock_list)

n_inits     <- 24
plot_titles <- paste0("Init value = ", 1:n_inits)

summary_optim         <- vector(mode = "list", length(cm_list))
names(summary_optim)  <- m_index
time_optim_pfr        <- vector(mode = "list", length(cm_list))
names(time_optim_pfr) <- m_index
```


#### Matrix A

#### Inits

\hfill


```{r optim_deterministic}
set.seed(18)

mtx        <- "A"

inits_A    <- get_matrix_inits(n_inits, conceptual_matrix_A)
inits_A_df <- as.data.frame(do.call(rbind, inits_A)) %>% 
  mutate(init_id = row_number(), .before = 1)

knitr::kable(inits_A_df, "latex", booktabs = TRUE)
```


```{r optim_fit_A}
var_cache   <- TRUE
output      <- optimise_SEIR2(inits_A, mtx, data_list_prf, sim_specs, var_cache,
                              pop_size)
optim_det_A           <- output$result
time_optim_pfr[[mtx]] <- output$time
```


```{r summary_optim_A, fig.height = 7}
source("./R/summarise_optim_fit.R")

summaries_optim_A <- map2(
  optim_det_A, plot_titles, summarise_optim_fit, 
  incidence_data = prf_df, conceptual_matrix = conceptual_matrix_A,
  pop_df = output_sp$population, actual_K = actual_K,
  g_options)

bf_search            <- find_best_fits(summaries_optim_A, n_inits)
top_id               <- bf_search$top_id
top_optim_A          <- summaries_optim_A[top_id]
summary_optim[[mtx]] <- summaries_optim_A[[bf_search$pos_best_fit]]

comparison_graphs <- purrr::map(top_optim_A, "g_comparison")
do.call("grid.arrange", c(comparison_graphs, ncol = 2))
```

```{r, fig.height = 7}
K_matrix <- purrr::map(top_optim_A , "g_K_hat")
do.call("grid.arrange", K_matrix)
```
\newpage

```{r}
g_ts_errors <- ts_errors(top_optim_A, top_id)
print(g_ts_errors)
```



```{r, fig.height = 2.5}
g_errors <- draw_inits_comparison(top_optim_A, output_sp$theoretical_R0, 
                                top_id) 
print(g_errors)
```

\newpage

#### Matrix B

#### Inits

\hfill


```{r inits_B}
set.seed(8046)

mtx        <- "B"

inits_B    <- get_matrix_inits(n_inits, conceptual_matrix_B)
inits_B_df <- as.data.frame(do.call(rbind, inits_B)) %>% 
  mutate(init_id = row_number(), .before = 1)

knitr::kable(inits_B_df, "latex", booktabs = TRUE)
```

```{r optim_fit_B}
var_cache <- TRUE
output    <- optimise_SEIR2(inits_B, mtx, data_list_prf, sim_specs, var_cache,
                            pop_size)

optim_det_B           <- output$result
time_optim_pfr[[mtx]] <- output$time
```


```{r summary_optim_B, fig.height = 7}
source("./R/summarise_optim_fit.R")

summaries_optim_B <- map2(
  optim_det_B, plot_titles, summarise_optim_fit, 
  incidence_data = prf_df, conceptual_matrix = conceptual_matrix_B,
  pop_df = output_sp$population, actual_K = actual_K,
  g_options)

bf_search            <- find_best_fits(summaries_optim_B, n_inits)
top_id               <- bf_search$top_id
top_optim_B          <- summaries_optim_B[top_id]
summary_optim[[mtx]] <- summaries_optim_B[[bf_search$pos_best_fit]]

comparison_graphs <- purrr::map(top_optim_B, "g_comparison")
do.call("grid.arrange", c(comparison_graphs, ncol = 2))
```

```{r}
K_matrix <- purrr::map(top_optim_B , "g_K_hat")
do.call("grid.arrange", K_matrix)
```

```{r}
g_ts_errors <- ts_errors(top_optim_B, top_id)
print(g_ts_errors)
```


```{r, fig.height = 2.5}
g_errors <- draw_inits_comparison(top_optim_B, output_sp$theoretical_R0, 
                                top_id) 
print(g_errors)
```

\newpage

#### Matrix C

#### Inits

\hfill

```{r inits_C}
set.seed(21766)

mtx        <- "C"

inits_C    <- get_matrix_inits(n_inits, conceptual_matrix_C)
inits_C_df <- as.data.frame(do.call(rbind, inits_C)) %>% 
  mutate(init_id = row_number(), .before = 1)

knitr::kable(inits_C_df, "latex", booktabs = TRUE)
```

```{r optim_fit_C}
var_cache   <- TRUE
output      <- optimise_SEIR2(inits_C, mtx, data_list_prf, sim_specs, var_cache,
                              pop_size)

optim_det_C           <- output$result
time_optim_pfr[[mtx]] <- output$time
```

```{r summary_optim_C, fig.height = 7}
source("./R/summarise_optim_fit.R")

summaries_optim_C <- map2(
  optim_det_C, plot_titles, summarise_optim_fit, 
  incidence_data = prf_df, conceptual_matrix = conceptual_matrix_C,
  pop_df = output_sp$population, actual_K = actual_K,
  g_options)

bf_search            <- find_best_fits(summaries_optim_C, n_inits)
top_id               <- bf_search$top_id
top_optim_C          <- summaries_optim_C[top_id]
summary_optim[[mtx]] <- summaries_optim_C[[bf_search$pos_best_fit]]

comparison_graphs <- purrr::map(top_optim_C, "g_comparison")
do.call("grid.arrange", c(comparison_graphs, ncol = 2))
```

```{r}
K_matrix <- purrr::map(top_optim_C , "g_K_hat")
do.call("grid.arrange", K_matrix)
```

```{r}
g_ts_errors <- ts_errors(top_optim_C, top_id)
print(g_ts_errors)
```


```{r, fig.height = 2.5}
g_errors <- draw_inits_comparison(top_optim_C, output_sp$theoretical_R0, 
                                top_id) 
print(g_errors)
```

\newpage

#### Matrix D

#### Inits

\hfill

```{r inits_D}
set.seed(84541)

mtx        <- "D"

inits_D    <- get_matrix_inits(n_inits, conceptual_matrix_D)
inits_D_df <- as.data.frame(do.call(rbind, inits_D)) %>% 
  mutate(init_id = row_number(), .before = 1)

knitr::kable(inits_D_df, "latex", booktabs = TRUE)
```

```{r optim_fit_D}
var_cache <- TRUE
output    <- optimise_SEIR2(inits_D, mtx, data_list_prf, sim_specs, var_cache,
                              pop_size)

optim_det_D           <- output$result
time_optim_pfr[[mtx]] <- output$time
```

```{r summary_optim_D, fig.height = 7}
source("./R/summarise_optim_fit.R")

summaries_optim_D <- map2(
  optim_det_D, plot_titles, summarise_optim_fit, 
  incidence_data = prf_df, conceptual_matrix = conceptual_matrix_D,
  pop_df = output_sp$population, actual_K = actual_K,
  g_options)

bf_search            <- find_best_fits(summaries_optim_D, n_inits)
top_id               <- bf_search$top_id
top_optim_D          <- summaries_optim_D[top_id]
summary_optim[[mtx]] <- summaries_optim_D[[bf_search$pos_best_fit]]

comparison_graphs <- purrr::map(top_optim_D, "g_comparison")
do.call("grid.arrange", c(comparison_graphs, ncol = 2))
```

```{r}
K_matrix <- purrr::map(top_optim_D , "g_K_hat")
do.call("grid.arrange", K_matrix)
```

```{r}
g_ts_errors <- ts_errors(top_optim_D, top_id)
print(g_ts_errors)
```


```{r, fig.height = 2.5}
g_errors <- draw_inits_comparison(top_optim_D, output_sp$theoretical_R0, 
                                top_id) 
print(g_errors)
```

\newpage
#### Symmetric matrix

```{r inits_sym}
source("./R/NMS_utils.R")

set.seed(51183)

mtx        <- "sym"

inits_sym    <- get_matrix_inits(n_inits, conceptual_matrix_sym)
inits_sym_df <- as.data.frame(do.call(rbind, inits_sym)) %>% 
  mutate(init_id = row_number(), .before = 1)

knitr::kable(inits_sym_df, "latex", booktabs = TRUE)
```

```{r optim_fit_sym}
var_cache <- TRUE
output    <- optimise_SEIR2(inits_sym, mtx, data_list_prf, sim_specs, 
                                var_cache, pop_size)

optim_det_sym         <- output$result
time_optim_pfr[[mtx]] <- output$time
```

```{r summary_optim_sym, fig.height = 7}
source("./R/summarise_optim_fit.R")

summaries_optim_sym <- map2(
  optim_det_sym, plot_titles, summarise_optim_fit, 
  incidence_data = prf_df, conceptual_matrix = conceptual_matrix_sym,
  pop_df = output_sp$population, actual_K = actual_K,
  g_options)

bf_search            <- find_best_fits(summaries_optim_sym, n_inits)
top_id               <- bf_search$top_id
top_optim_sym        <- summaries_optim_sym[top_id]
summary_optim[[mtx]] <- summaries_optim_sym[[bf_search$pos_best_fit]]

comparison_graphs <- purrr::map(top_optim_sym, "g_comparison")
do.call("grid.arrange", c(comparison_graphs, ncol = 2))
```

```{r}
K_matrix <- purrr::map(top_optim_sym, "g_K_hat")
do.call("grid.arrange", K_matrix)
```

```{r}
g_ts_errors <- ts_errors(top_optim_sym, top_id)
print(g_ts_errors)
```


```{r, fig.height = 2.5}
g_errors <- draw_inits_comparison(top_optim_sym, output_sp$theoretical_R0, 
                                top_id) 
print(g_errors)
```

\newpage

### By Stan

```{r params_Stan_sc1}
source("./R/stan_utils.R")
source("./R/write_SEIR_model.R")
source("./R/summarise_results.R")

n_warm_up <- 1000
n_iter    <- 1000
n_chains  <- 4

arg_list_outline <- list(fit    = NULL,
                         data   = NULL, 
                         chains = n_chains,
                         warmup = n_warm_up, 
                         iter   = n_iter, 
                         cores  = 4,
                         seed   = NULL, 
                         refresh = 5)

stan_d_outline <- list(n_obs    = length_data,
                       n_params = NULL,
                       n_difeq  = 20, # number of differential equations
                       y1       = data_list_prf[[1]],
                       y2       = data_list_prf[[2]],
                       y3       = data_list_prf[[3]],
                       y4       = data_list_prf[[4]],
                       t0       = 0,
                       ts       = 1:length_data)

summary_stan         <- vector(mode = "list", length(cm_list))
names(summary_stan)  <- m_index

time_stan_pfr        <- vector(mode = "list", length(cm_list))
names(time_stan_pfr) <- m_index
```


#### Matrix A

```{r stan_fit_A}
mtx          <- "A"
filename     <- str_glue("./Stan_files/Det_{mtx}.stan")
params_prior <- "  params ~ normal(0, 10)"

o_SEIR_A     <- write_SEIR_model(mtx, filename, output_gsi$stock_list, 
                                 params_prior, pop_size = pop_size)

stan_d          <- stan_d_outline
n_params        <- length(unique(conceptual_matrix_A))
stan_d$n_params <- n_params

seed             <- 1677265156
arg_list         <- arg_list_outline
arg_list$data    <- stan_d
arg_list$seed    <- seed
arg_list$data$y0 <- o_SEIR_A$stock_inits

var_cache             <- TRUE
cache_file            <- str_glue("./object_fits/Stan/stan_fit_{mtx}.rds")
output                <- run_stan(filename, var_cache, cache_file, arg_list)
stan_fit_A            <- output$stan_fit
time_stan_pfr[[mtx]]  <- output$time
```
\hfill

```{r}
smy_obj <- rstan::summary(stan_fit_A, 
                          str_glue("params[{1:n_params}]"))

sum_mtx <- smy_obj$summary %>% as.data.frame()
rownames(sum_mtx) <- o_SEIR_A$params
kable(sum_mtx[, c("mean", "sd", "n_eff", "Rhat")], booktab = TRUE)
```


```{r, fig.height = 2.5, fig.width = 5.5, fig.align = 'center'}
specs_list <- list(x_pos = 2.305, ypos_mean = 29, ypos_median = 26,
                   text_size = 2, ypos_interval = 23,
                   title = "Matrix A", xlabel = "")

summary_stan[[mtx]] <- summarise_results(stan_fit_A, conceptual_matrix_A,
                                         prf_df, 
                                         output_sp$population, specs_list, 
                                         o_SEIR_A$params, actual_K)

pred_K <- summary_stan[[mtx]]$summary_k$g_k_hat + 
  labs(subtitle = "Predicted K")

grid.arrange(pred_K, grey_actual_K, ncol = 2)
```

```{r}
summary_stan[[mtx]]$summary_k$g_pairs
```


```{r g_ts_stan_A, fig.height = 2.5, fig.align = 'center'}
summary_stan[[mtx]]$ts_summary$g_comparison
```

```{r, fig.height = 2.5, fig.width = 4, fig.align= 'center'}
summary_stan[[mtx]]$R_0$g
```


\newpage

#### Matrix B

```{r stan_fit_B}
mtx          <- "B"
filename     <- str_glue("./Stan_files/Det_{mtx}.stan")
params_prior <- "  params ~ normal(0, 10)"

o_SEIR_B        <- write_SEIR_model(mtx, filename, output_gsi$stock_list, 
                                    params_prior, pop_size = pop_size)

stan_d          <- stan_d_outline
stan_d$n_params <- length(unique(conceptual_matrix_B))

seed             <- 1298600913
arg_list         <- arg_list_outline
arg_list$data    <- stan_d
arg_list$seed    <- seed
arg_list$data$y0 <- o_SEIR_B$stock_inits

var_cache             <- TRUE
cache_file            <- str_glue("./object_fits/Stan/stan_fit_{mtx}.rds")
output                <- run_stan(filename, var_cache, cache_file, arg_list)
stan_fit_B            <- output$stan_fit
time_stan_pfr[[mtx]]  <- output$time
```

\hfill

```{r}
smy_obj <- rstan::summary(stan_fit_B, 
                          str_glue("params[{1:n_params}]"))

sum_mtx <- smy_obj$summary %>% as.data.frame()
rownames(sum_mtx) <- o_SEIR_B$params
kable(sum_mtx[, c("mean", "sd", "n_eff", "Rhat")], booktab = TRUE)
```

```{r, fig.height = 2.5, fig.width = 5.5, fig.align = 'center'}
source("./R/summarise_results.R")

specs_list <- list(x_pos = 2.275, ypos_mean = 35, ypos_median = 31,
                   text_size = 2, ypos_interval = 27,
                   title = "Matrix B", xlabel = "")

summary_stan[[mtx]] <- summarise_results(stan_fit_B, conceptual_matrix_B,
                                         prf_df, 
                                         output_sp$population,
                                         specs_list, o_SEIR_B$params,
                                         actual_K)

pred_K <- summary_stan[[mtx]]$summary_k$g_k_hat + 
  labs(subtitle = "Predicted K")

grid.arrange(pred_K, grey_actual_K, ncol = 2)
```

```{r}
summary_stan[[mtx]]$summary_k$g_pairs
```

```{r g_ts_stan_B, fig.height = 2.5, fig.align = 'center'}
summary_stan[[mtx]]$ts_summary$g_comparison
```

```{r, fig.height = 2.5, fig.width = 4, fig.align= 'center'}
summary_stan[[mtx]]$R_0$g
```

\newpage

#### Matrix C

```{r stan_fit_C}
mtx          <- "C"
filename     <- str_glue("./Stan_files/Det_{mtx}.stan")
params_prior <- "  params ~ normal(0, 10)"

o_SEIR_C     <- write_SEIR_model(mtx, filename, output_gsi$stock_list, 
                                 params_prior, pop_size = pop_size)

stan_d          <- stan_d_outline
stan_d$n_params <- length(unique(conceptual_matrix_C))

seed             <- 615190293
arg_list         <- arg_list_outline
arg_list$data    <- stan_d
arg_list$seed    <- seed
arg_list$data$y0 <- o_SEIR_C$stock_inits

var_cache             <- TRUE
cache_file            <- str_glue("./object_fits/Stan/stan_fit_{mtx}.rds")
output                <- run_stan(filename, var_cache, cache_file, arg_list)
stan_fit_C            <- output$stan_fit
time_stan_pfr[[mtx]]  <- output$time
```

\hfill

```{r}
smy_obj <- rstan::summary(stan_fit_C, 
                          str_glue("params[{1:n_params}]"))

sum_mtx <- smy_obj$summary %>% as.data.frame()
rownames(sum_mtx) <- o_SEIR_C$params
kable(sum_mtx[, c("mean", "sd", "n_eff", "Rhat")], booktab = TRUE)
```

```{r, fig.height = 2.5, fig.width = 5.5, fig.align = 'center'}
source("./R/summarise_results.R")

specs_list <- list(x_pos = 2.315, ypos_mean = 36, ypos_median = 32,
                     text_size = 2, ypos_interval = 28,
                     title = "Matrix C", xlabel = "")

summary_stan[[mtx]] <- summarise_results(stan_fit_C, conceptual_matrix_C,
                                         prf_df, 
                                         output_sp$population,
                                         specs_list, o_SEIR_C$params,
                                         actual_K)

pred_K <- summary_stan[[mtx]]$summary_k$g_k_hat + 
  labs(subtitle = "Predicted K")

grid.arrange(pred_K, grey_actual_K, ncol = 2)
```

```{r}
summary_stan[[mtx]]$summary_k$g_pairs
```

```{r g_ts_stan_C, fig.height = 2.5, fig.align = 'center'}
summary_stan[[mtx]]$ts_summary$g_comparison
```

```{r, fig.height = 2.5, fig.width = 4, fig.align= 'center'}
summary_stan[[mtx]]$R_0$g
```

\newpage

#### Matrix D

```{r stan_fit_D}
mtx          <- "D"
filename     <- str_glue("./Stan_files/Det_{mtx}.stan")
params_prior <- "  params ~ normal(0, 10)"

o_SEIR_D     <- write_SEIR_model(mtx, filename, output_gsi$stock_list, 
                                 params_prior, pop_size = pop_size)

stan_d          <- stan_d_outline
stan_d$n_params <- length(unique(conceptual_matrix_D))

seed             <- 12011990
arg_list         <- arg_list_outline
arg_list$data    <- stan_d
arg_list$seed    <- seed
arg_list$data$y0 <- o_SEIR_D$stock_inits

var_cache             <- TRUE
cache_file            <- str_glue("./object_fits/Stan/stan_fit_{mtx}.rds")
output                <- run_stan(filename, var_cache, cache_file, arg_list)
stan_fit_D            <- output$stan_fit
time_stan_pfr[[mtx]]  <- output$time
```

\hfill

```{r}
smy_obj <- rstan::summary(stan_fit_D, 
                          str_glue("params[{1:n_params}]"))

sum_mtx <- smy_obj$summary %>% as.data.frame()
rownames(sum_mtx) <- o_SEIR_D$params
kable(sum_mtx[, c("mean", "sd", "n_eff", "Rhat")], booktab = TRUE)
```


```{r, fig.height = 2.5, fig.width = 5.5, fig.align = 'center'}
specs_list <- list(x_pos = 2.31, ypos_mean = 28, ypos_median = 26,
                     text_size = 2, ypos_interval = 24,
                     title = "Matrix D", xlabel = "")

summary_stan[[mtx]] <- summarise_results(stan_fit_D, conceptual_matrix_D,
                                         prf_df, 
                                         output_sp$population, specs_list, 
                                         o_SEIR_D$params,
                                         actual_K)

pred_K <- summary_stan[[mtx]]$summary_k$g_k_hat + 
  labs(subtitle = "Predicted K")

grid.arrange(pred_K, grey_actual_K, ncol = 2)
```

```{r}
summary_stan[[mtx]]$summary_k$g_pairs
```

```{r g_ts_stan_D, fig.height = 2.5, fig.align = 'center'}
summary_stan[[mtx]]$ts_summary$g_comparison
```
```{r, fig.height = 2.5, fig.width = 4, fig.align= 'center'}
summary_stan[[mtx]]$R_0$g
```


```{r}
params_translation <- data.frame(
  original = c("params[1]", "params[2]", "params[3]", "params[4]"),
  new      = c("kappa[11]", "kappa[22]", "kappa[33]", "kappa[44]"),
  stringsAsFactors = FALSE)

color_scheme_set("purple")
posterior  <- rstan::extract(stan_fit_D, inc_warmup = TRUE, permuted = FALSE)
post_names <- dimnames(posterior)[[3]]

post_names[match(params_translation$original, post_names)] <- params_translation$new
dimnames(posterior)[[3]] <- post_names
g_for_plot <- mcmc_trace(posterior, pars = c("kappa[11]", "kappa[22]",
                                             "kappa[33]", "kappa[44]"),
           facet_args = list(labeller = label_parsed),
           n_warmup = 1000) +
  theme_minimal()

print(g_for_plot)

ggsave(file = "./plots/traceplot_D.pdf", g_for_plot, dpi = "print",
       height = 4, width = 6)
```
\newpage

#### Symmetric matrix


```{r stan_fit_sym}
mtx          <- "sym"
filename     <- str_glue("./Stan_files/Det_{mtx}.stan")
params_prior <- "  params ~ normal(0, 10)"

o_SEIR_sym   <- write_SEIR_model(mtx, filename, output_gsi$stock_list, 
                                 params_prior, pop_size = pop_size)

stan_d          <- stan_d_outline
n_params        <- length(unique(conceptual_matrix_sym))
stan_d$n_params <- n_params

seed             <- 936357173
arg_list         <- arg_list_outline
arg_list$data    <- stan_d
arg_list$seed    <- seed
arg_list$data$y0 <- o_SEIR_sym$stock_inits

var_cache             <- TRUE
cache_file            <- str_glue("./object_fits/Stan/stan_fit_{mtx}.rds")
output                <- run_stan(filename, var_cache, cache_file, arg_list)
stan_fit_sym          <- output$stan_fit
time_stan_pfr[[mtx]]  <- output$time
```

\hfill

```{r}
smy_obj <- rstan::summary(stan_fit_sym, 
                          str_glue("params[{1:n_params}]"))

sum_mtx <- smy_obj$summary %>% as.data.frame()
rownames(sum_mtx) <- o_SEIR_sym$params
kable(sum_mtx[, c("mean", "sd", "n_eff", "Rhat")], booktab = TRUE)
```

```{r, fig.height = 2.5, fig.width = 5.5, fig.align = 'center'}
source("./R/summarise_results.R")

specs_list <- list(x_pos = 2.31, ypos_mean = 30, ypos_median = 26,
                   text_size = 2, ypos_interval = 22,
                   title = "Symmetric matrix", xlabel = "")

summary_stan[[mtx]] <- summarise_results(stan_fit_sym, conceptual_matrix_sym,
                                         prf_df, 
                                         output_sp$population,
                                         specs_list, o_SEIR_sym$params,
                                         actual_K)

pred_K <- summary_stan[[mtx]]$summary_k$g_k_hat + 
  labs(subtitle = "Predicted K")

grid.arrange(pred_K, grey_actual_K, ncol = 2)

ggsave(file = "./plots/WAIFW_sym_HMC.pdf", g_for_plot, dpi = "print",
       height = 3, width = 6)
```

```{r}
summary_stan[[mtx]]$summary_k$g_pairs
```

```{r g_ts_stan_sym, fig.height = 2.5, fig.align = 'center'}
summary_stan[[mtx]]$ts_summary$g_comparison
```

```{r, fig.height = 2.5, fig.width = 4, fig.align= 'center'}
summary_stan[[mtx]]$R_0$g
```

### Incidence data goodness of fit

```{r MSE_timeseries_optim}
MASEs <- purrr::map(summary_optim, "metrics") %>% 
  map_dbl("avg_MASE")

MSEs <- purrr::map(summary_optim, "metrics") %>% 
  map_dbl("avg_MSE")

errors_ts_optim <- data.frame(matrix = m_index,
                             MASE = MASEs,
                             MSE  = MSEs,
                             method = "NMS",
                             model = "Perfect information") %>% 
  mutate(is_min = ifelse(MASE == min(MASE), TRUE, FALSE))
```

```{r error_timeseries_stan}
MASEs <- purrr::map(summary_stan, "ts_summary") %>% 
  map_dbl("MASE")

MSEs <- purrr::map(summary_stan, "ts_summary") %>% 
  map_dbl("MSE")

errors_ts_stan <- data.frame(matrix = m_index,
                             MASE = MASEs,
                             MSE  = MSEs,
                             method = "HMC",
                             model = "Perfect information") %>% 
  mutate(is_min = ifelse(MASE == min(MASE), TRUE, FALSE))
```


```{r, fig.height = 3}
error_ts <- bind_rows(errors_ts_optim, errors_ts_stan)

ggplot(error_ts, aes(x = matrix, y = MASE)) +
  geom_lollipop(aes(colour = is_min)) +
  scale_colour_manual(values = c("grey", "steelblue")) +
  coord_flip() +
  geom_text(aes(label = round(MASE, 2)), nudge_y = 0.1, size = 3) +
  facet_wrap(~ method) +
  theme_test() +
  theme(legend.position = "none")

ggsave("./plots/incidence_fit_perfect_info.pdf", dpi = "print", height = 3,
       width = 8)
```

### Likelihood

```{r}
log_liks <- purrr::map(summary_optim, "metrics") %>% 
  map_dbl("log_lik") 
  
log_liks_optim <- data.frame(matrix  = m_index,
                             log_lik = log_liks,
                             method  = "NMS") %>% 
  mutate(is_max = ifelse(log_lik == max(log_lik), TRUE, FALSE))

log_liks <- purrr::map(summary_stan, "ts_summary") %>% 
  map_dbl("log_lik")

log_liks_stan <- data.frame(matrix  = m_index,
                             log_lik = log_liks,
                             method  = "HMC") %>% 
  mutate(is_max = ifelse(log_lik == max(log_lik), TRUE, FALSE))

log_liks_df <- bind_rows(log_liks_optim, log_liks_stan)

ggplot(log_liks_df , aes(x = matrix, y = log_lik)) +
  geom_point(aes(colour = is_max)) +
  scale_colour_manual(values = c("grey", "steelblue")) +
  coord_flip() +
  geom_text(aes(label = round(log_lik, 1), colour = is_max), 
            nudge_y = -65, size = 2) +
  facet_wrap(~ method, ncol = 1) +
  theme_test() +
  theme(legend.position = "none") +
  labs(y = "Log-likelihood",
       x = "Structure")
```




\newpage

## Underreporting

### By optimisation

```{r optim_und, cache = FALSE}
n_inits <- 48

sim_specs <- list(start_time   = 0,
                  stop_time    = stop_time,
                  step_size    = 1 / 32,
                  integ_method = "rk4",
                  stock_list   = output_gsi$stock_list)

plot_titles <- paste0("Init value = ", 1:n_inits)

g_options <- list(stripSize = 4,
                  legendPosition = "bottom",
                  axisTextXSize = 4,
                  axisTextYSize = 4,
                  axisTitleSize = 5,
                  legendSize    = 4,
                  legendBoxMargin = FALSE,
                  titleSize = 6)

summary_und_optim        <- vector(mode = "list", length(cm_list))
names(summary_und_optim) <- m_index
time_optim_und           <- vector(mode = "list", length(cm_list))
names(time_optim_und)    <- m_index
```

#### Matrix A

```{r inits_und_A}
set.seed(3890)

mtx        <- "A"

inits_A    <- get_matrix_inits(n_inits, cm_list[[mtx]], 
                               reporting_fraction = TRUE)

inits_df <- as.data.frame(do.call(rbind, inits_A)) %>% 
  mutate(init_id = row_number(), .before = 1)

knitr::kable(inits_df, "latex", booktabs = TRUE)
```

```{r optim_und_A}
var_cache    <- TRUE
output       <- optimise_SEIR2(inits_A, mtx, data_list_und, sim_specs, var_cache,
                               pop_size, "underreporting")

optim_und_A           <- output$result
time_optim_und[[mtx]] <- output$time
```


```{r summary_und_optim_A, fig.height = 7}
source("./R/summarise_optim_fit.R")

summaries_optim_und_A <- map2(
  optim_und_A, plot_titles, summarise_optim_fit, 
  incidence_data = und_df, conceptual_matrix = cm_list[[mtx]],
  pop_df = output_sp$population, actual_K = actual_K,
  g_options)

bf_search                <- find_best_fits(summaries_optim_und_A, n_inits)
top_id                   <- bf_search$top_id
top_optim_A              <- summaries_optim_und_A[top_id]
summary_und_optim[[mtx]] <- summaries_optim_und_A[[bf_search$pos_best_fit]]

comparison_graphs <- purrr::map(top_optim_A, "g_comparison")
do.call("grid.arrange", c(comparison_graphs, ncol = 2))
```
```{r}
K_matrix <- purrr::map(top_optim_A, "g_K_hat")
do.call("grid.arrange", K_matrix)
```

```{r}
g_ts_errors <- ts_errors(top_optim_A, top_id)
print(g_ts_errors)
```


```{r, fig.height = 2.5}
g_errors <- draw_inits_comparison(top_optim_A, output_sp$theoretical_R0, 
                                top_id) 
print(g_errors)
```

\newpage

#### Matrix B

```{r inits_und_B}
set.seed(580)

mtx        <- "B"

inits_B    <- get_matrix_inits(n_inits, cm_list[[mtx]], 
                               reporting_fraction = TRUE)

inits_df <- as.data.frame(do.call(rbind, inits_B)) %>% 
  mutate(init_id = row_number(), .before = 1)

knitr::kable(inits_df, "latex", booktabs = TRUE)
```

```{r optim_und_B}
var_cache    <- TRUE
output       <- optimise_SEIR2(inits_B, mtx, data_list_und, sim_specs, var_cache,
                               pop_size, "underreporting")

optim_und_B           <- output$result
time_optim_und[[mtx]] <- output$time
```

```{r summary_und_optim_B, fig.height = 7}
source("./R/summarise_optim_fit.R")

summaries_optim_und_B <- map2(
  optim_und_B, plot_titles, summarise_optim_fit, 
  incidence_data = und_df, conceptual_matrix = cm_list[[mtx]],
  pop_df = output_sp$population, actual_K = actual_K,
  g_options)

bf_search                <- find_best_fits(summaries_optim_und_B, n_inits)
top_id                   <- bf_search$top_id
top_optim_B              <- summaries_optim_und_B[top_id]
summary_und_optim[[mtx]] <- summaries_optim_und_B[[bf_search$pos_best_fit]]

comparison_graphs <- purrr::map(top_optim_B, "g_comparison")
do.call("grid.arrange", c(comparison_graphs, ncol = 2))
```

```{r}
K_matrix <- purrr::map(top_optim_B, "g_K_hat")
do.call("grid.arrange", K_matrix)
```

```{r}
g_ts_errors <- ts_errors(top_optim_B, top_id)
print(g_ts_errors)
```


```{r, fig.height = 2.5}
g_errors <- draw_inits_comparison(top_optim_B, output_sp$theoretical_R0, 
                                top_id) 
print(g_errors)
```

\newpage

#### Matrix C

```{r inits_und_C}
set.seed(4647)

mtx        <- "C"

inits_C    <- get_matrix_inits(n_inits, cm_list[[mtx]], 
                               reporting_fraction = TRUE)

inits_df <- as.data.frame(do.call(rbind, inits_C)) %>% 
  mutate(init_id = row_number(), .before = 1)

knitr::kable(inits_df, "latex", booktabs = TRUE)
```

```{r optim_und_C}
var_cache    <- TRUE
output       <- optimise_SEIR2(inits_C, mtx, data_list_und, sim_specs, var_cache,
                               pop_size, "underreporting")

optim_und_C           <- output$result
time_optim_und[[mtx]] <- output$time
```

```{r summary_und_optim_C, fig.height = 7}
source("./R/summarise_optim_fit.R")

summaries_optim_und_C <- map2(
  optim_und_C, plot_titles, summarise_optim_fit, 
  incidence_data = und_df, conceptual_matrix = cm_list[[mtx]],
  pop_df = output_sp$population, actual_K = actual_K,
  g_options)

bf_search                <- find_best_fits(summaries_optim_und_C, n_inits)
top_id                   <- bf_search$top_id
top_optim_C              <- summaries_optim_und_C[top_id]
summary_und_optim[[mtx]] <- summaries_optim_und_C[[bf_search$pos_best_fit]]

comparison_graphs <- purrr::map(top_optim_C, "g_comparison")
do.call("grid.arrange", c(comparison_graphs, ncol = 2))
```
```{r}
K_matrix <- purrr::map(top_optim_C, "g_K_hat")
do.call("grid.arrange", K_matrix)
```
```{r}
g_ts_errors <- ts_errors(top_optim_C, top_id)
print(g_ts_errors)
```


```{r, fig.height = 2.5}
g_errors <- draw_inits_comparison(top_optim_C, output_sp$theoretical_R0, 
                                top_id) 
print(g_errors)
```



\newpage

#### Matrix D

```{r inits_und_D}
set.seed(2860)

mtx        <- "D"

inits_D    <- get_matrix_inits(n_inits, cm_list[[mtx]], 
                               reporting_fraction = TRUE)

inits_df <- as.data.frame(do.call(rbind, inits_D)) %>% 
  mutate(init_id = row_number(), .before = 1)

knitr::kable(inits_df, "latex", booktabs = TRUE)
```

```{r optim_und_D}
var_cache    <- TRUE
output       <- optimise_SEIR2(inits_D, mtx, data_list_und, sim_specs, var_cache,
                               pop_size, "underreporting")

optim_und_D           <- output$result
time_optim_und[[mtx]] <- output$time
```

```{r summary_und_optim_D, fig.height = 7}
source("./R/summarise_optim_fit.R")

summaries_optim_und_D <- map2(
  optim_und_D, plot_titles, summarise_optim_fit, 
  incidence_data = und_df, conceptual_matrix = cm_list[[mtx]],
  pop_df = output_sp$population, actual_K = actual_K,
  g_options)

bf_search                <- find_best_fits(summaries_optim_und_D, n_inits)
top_id                   <- bf_search$top_id
top_optim_D              <- summaries_optim_und_D[top_id]
summary_und_optim[[mtx]] <- summaries_optim_und_D[[bf_search$pos_best_fit]]

comparison_graphs <- purrr::map(top_optim_D, "g_comparison")
do.call("grid.arrange", c(comparison_graphs, ncol = 2))
```

```{r}
K_matrix <- purrr::map(top_optim_D, "g_K_hat")
do.call("grid.arrange", K_matrix)
```


```{r}
g_ts_errors <- ts_errors(top_optim_D, top_id)
print(g_ts_errors)
```


```{r, fig.height = 2.5}
g_errors <- draw_inits_comparison(top_optim_D, output_sp$theoretical_R0, 
                                top_id) 
print(g_errors)
```

\newpage

#### Symmetric matrix

```{r inits_und_S}
set.seed(2860)

mtx        <- "sym"

inits_sym    <- get_matrix_inits(n_inits, cm_list[[mtx]], 
                               reporting_fraction = TRUE)

inits_df <- as.data.frame(do.call(rbind, inits_sym)) %>% 
  mutate(init_id = row_number(), .before = 1)

knitr::kable(inits_df, "latex", booktabs = TRUE)
```

```{r optim_und_S}
var_cache      <- TRUE
output         <- optimise_SEIR2(inits_sym, mtx, data_list_und, sim_specs, var_cache,
                               pop_size, "underreporting")

optim_und_sym         <- output$result
time_optim_und[[mtx]] <- output$time
```

```{r summary_und_optim_S, fig.height = 7}
source("./R/summarise_optim_fit.R")

summaries_optim_und_sym <- map2(
  optim_und_sym, plot_titles, summarise_optim_fit, 
  incidence_data = und_df, conceptual_matrix = cm_list[[mtx]],
  pop_df = output_sp$population, actual_K = actual_K,
  g_options)

bf_search                <- find_best_fits(summaries_optim_und_sym, n_inits)
top_id                   <- bf_search$top_id
top_optim_sym            <- summaries_optim_und_sym[top_id]
summary_und_optim[[mtx]] <- summaries_optim_und_sym[[bf_search$pos_best_fit]]

comparison_graphs <- purrr::map(top_optim_sym, "g_comparison")
do.call("grid.arrange", c(comparison_graphs, ncol = 2))
```

```{r}
K_matrix <- purrr::map(top_optim_sym, "g_K_hat")
do.call("grid.arrange", K_matrix)
```
```{r}
g_ts_errors <- ts_errors(top_optim_sym, top_id)
print(g_ts_errors)
```


```{r, fig.height = 2.5}
g_errors <- draw_inits_comparison(top_optim_sym, output_sp$theoretical_R0, 
                                top_id) 
print(g_errors)
```


\newpage

### By Stan

```{r params_Stan_und}
source("./R/stan_utils.R")
source("./R/write_SEIR_model.R")
source("./R/summarise_results.R")

n_warm_up <- 1000
n_iter    <- 1000
n_chains  <- 4

arg_list_outline <- list(fit    = NULL,
                         data   = NULL, 
                         chains = n_chains,
                         warmup = n_warm_up, 
                         iter   = n_iter, 
                         cores  = 4,
                         seed   = NULL, 
                         refresh = 5)

stan_d_outline <- list(n_obs    = length_data,
                       n_params = NULL,
                       n_difeq  = 20, # number of differential equations
                       y1       = data_list_und[[1]],
                       y2       = data_list_und[[2]],
                       y3       = data_list_und[[3]],
                       y4       = data_list_und[[4]],
                       t0       = 0,
                       ts       = 1:length_data)

summary_stan_und         <- vector(mode = "list", length(cm_list))
names(summary_stan_und)  <- m_index

time_stan_und           <- vector(mode = "list", length(cm_list))
names(time_stan_und)    <- m_index
```


#### Matrix A

```{r stan_und_A}
mtx          <- "A"
filename     <- str_glue("./Stan_files/Und_{mtx}.stan")

params_prior <- c("  params ~ normal(0, 10)", 
                  "  rho    ~ normal(0.5, 0.5)")

o_SEIR_A_und <- write_SEIR_model(mtx, filename, output_gsi$stock_list, 
                                 params_prior, pop_size = pop_size, 
                                 "underreporting")

stan_d          <- stan_d_outline
n_params        <- length(unique(cm_list[[mtx]]))
stan_d$n_params <- n_params 

seed             <- 571156516
arg_list         <- arg_list_outline
arg_list$data    <- stan_d
arg_list$seed    <- seed
arg_list$data$y0 <- o_SEIR_A_und$stock_inits

var_cache            <- TRUE
cache_file           <- str_glue("./object_fits/Stan/stan_fit_und_{mtx}.rds")
output               <- run_stan(filename, var_cache, cache_file, arg_list)
stan_und_A           <- output$stan_fit
time_stan_und[[mtx]] <- output$time
```

\hfill

```{r}
smy_obj <- rstan::summary(stan_und_A, 
                          c("rho", str_glue("params[{1:n_params}]")))

sum_mtx <- smy_obj$summary %>% as.data.frame()
rownames(sum_mtx) <- c("rho", o_SEIR_A_und$params)
kable(sum_mtx[, c("mean", "sd", "n_eff", "Rhat")], booktab = TRUE)
```

```{r, fig.height = 2.5, fig.width = 5.5, fig.align = 'center'}
specs_list <- list(x_pos = 2.315, ypos_mean = 20, ypos_median = 17,
                   text_size = 2, ypos_interval = 14,
                   title = "Matrix A", xlabel = "")

summary_stan_und[[mtx]] <- summarise_results(stan_und_A, cm_list[[mtx]],
                                         und_df, 
                                         output_sp$population, specs_list, 
                                         o_SEIR_A_und$params, actual_K,
                                         scenario = "underreporting")

pred_K <- summary_stan_und[[mtx]]$summary_k$g_k_hat + 
  labs(subtitle = "Predicted K")

grid.arrange(pred_K, grey_actual_K, ncol = 2)
```

```{r}
summary_stan_und[[mtx]]$summary_k$g_pairs
```

```{r g_ts_stan_und_A, fig.height = 2.5, fig.align = 'center'}
summary_stan_und[[mtx]]$ts_summary$g_comparison
```
```{r, fig.height = 2.5, fig.width = 4, fig.align= 'center'}
summary_stan_und[[mtx]]$R_0$g
```
\newpage

#### Matrix B

```{r stan_und_B}
mtx          <- "B"
filename     <- str_glue("./Stan_files/Und_{mtx}.stan")

params_prior <- c("  params ~ normal(0, 10)", 
                  "  rho    ~ normal(0.5, 0.5)")

o_SEIR_B_und <- write_SEIR_model(mtx, filename, output_gsi$stock_list, 
                                 params_prior, pop_size = pop_size, 
                                 "underreporting")

stan_d          <- stan_d_outline
stan_d$n_params <- length(unique(cm_list[[mtx]]))

seed             <- 801275507
arg_list         <- arg_list_outline
arg_list$data    <- stan_d
arg_list$seed    <- seed
arg_list$data$y0 <- o_SEIR_B_und$stock_inits

var_cache            <- TRUE
cache_file           <- str_glue("./object_fits/Stan/stan_fit_und_{mtx}.rds")
output               <- run_stan(filename, var_cache, cache_file, arg_list)
stan_und_B           <- output$stan_fit
time_stan_und[[mtx]] <- output$time
```

\hfill

```{r}
smy_obj <- rstan::summary(stan_und_B, 
                          c("rho", str_glue("params[{1:n_params}]")))

sum_mtx <- smy_obj$summary %>% as.data.frame()
rownames(sum_mtx) <- c("rho", o_SEIR_B_und$params)
kable(sum_mtx[, c("mean", "sd", "n_eff", "Rhat")], booktab = TRUE)
```

```{r, fig.height = 2.5, fig.width = 5.5, fig.align = 'center'}
specs_list <- list(x_pos = 2.2775, ypos_mean = 32, ypos_median = 28,
                   text_size = 2, ypos_interval = 24,
                   title = "Matrix B", xlabel = "")


summary_stan_und[[mtx]] <- summarise_results(stan_und_B, cm_list[[mtx]],
                                         und_df, 
                                         output_sp$population, specs_list, 
                                         o_SEIR_B_und$params, actual_K,
                                         scenario = "underreporting")

pred_K <- summary_stan_und[[mtx]]$summary_k$g_k_hat + 
  labs(subtitle = "Predicted K")

grid.arrange(pred_K, grey_actual_K, ncol = 2)
```

```{r}
summary_stan_und[[mtx]]$summary_k$g_pairs
```

```{r g_ts_stan_und_B, fig.height = 2.5, fig.align = 'center'}
summary_stan_und[[mtx]]$ts_summary$g_comparison
```
```{r, fig.height = 2.5, fig.width = 4, fig.align= 'center'}
summary_stan_und[[mtx]]$R_0$g
```

\newpage

#### Matrix C

```{r stan_und_C}
mtx          <- "C"
filename     <- str_glue("./Stan_files/Und_{mtx}.stan")

params_prior <- c("  params ~ normal(0, 10)", 
                  "  rho    ~ normal(0.5, 0.5)")

o_SEIR_C_und <- write_SEIR_model(mtx, filename, output_gsi$stock_list, 
                                 params_prior, pop_size = pop_size, 
                                 "underreporting")

stan_d          <- stan_d_outline
stan_d$n_params <- length(unique(cm_list[[mtx]]))

seed             <- 801275507
arg_list         <- arg_list_outline
arg_list$data    <- stan_d
arg_list$seed    <- seed
arg_list$data$y0 <- o_SEIR_C_und$stock_inits

var_cache            <- TRUE
cache_file           <- str_glue("./object_fits/Stan/stan_fit_und_{mtx}.rds")
output               <- run_stan(filename, var_cache, cache_file, arg_list)
stan_und_C           <- output$stan_fit
time_stan_und[[mtx]] <- output$time
```

\hfill

```{r}
smy_obj <- rstan::summary(stan_und_C, 
                          c("rho", str_glue("params[{1:n_params}]")))

sum_mtx <- smy_obj$summary %>% as.data.frame()
rownames(sum_mtx) <- c("rho", o_SEIR_C_und$params)
kable(sum_mtx[, c("mean", "sd", "n_eff", "Rhat")], booktab = TRUE)
```

```{r, fig.height = 2.5, fig.width = 5.5, fig.align = 'center'}
specs_list <- list(x_pos = 2.317, ypos_mean = 30, ypos_median = 27,
                   text_size = 2, ypos_interval = 24,
                   title = "Matrix C", xlabel = "")


summary_stan_und[[mtx]] <- summarise_results(stan_und_C, cm_list[[mtx]],
                                         und_df, 
                                         output_sp$population, specs_list, 
                                         o_SEIR_C_und$params, actual_K,
                                         scenario = "underreporting")

pred_K <- summary_stan_und[[mtx]]$summary_k$g_k_hat + 
  labs(subtitle = "Predicted K")

grid.arrange(pred_K, grey_actual_K, ncol = 2)
```

```{r}
summary_stan_und[[mtx]]$summary_k$g_pairs
```

```{r g_ts_stan_und_C, fig.height = 2.5, fig.align = 'center'}
summary_stan_und[[mtx]]$ts_summary$g_comparison
```
```{r, fig.height = 2.5, fig.width = 4, fig.align= 'center'}
summary_stan_und[[mtx]]$R_0$g
```

\newpage

#### Matrix D

```{r stan_und_D}
mtx          <- "D"
filename     <- str_glue("./Stan_files/Und_{mtx}.stan")

params_prior <- c("  params ~ normal(0, 10)", 
                  "  rho    ~ normal(0.5, 0.5)")

o_SEIR_D_und <- write_SEIR_model(mtx, filename, output_gsi$stock_list, 
                                 params_prior, pop_size = pop_size, 
                                 "underreporting")

stan_d          <- stan_d_outline
stan_d$n_params <- length(unique(cm_list[[mtx]]))

seed             <- 1671919809
arg_list         <- arg_list_outline
arg_list$data    <- stan_d
arg_list$seed    <- seed
arg_list$data$y0 <- o_SEIR_D_und$stock_inits

var_cache            <- TRUE
cache_file           <- str_glue("./object_fits/Stan/stan_fit_und_{mtx}.rds")
output               <- run_stan(filename, var_cache, cache_file, arg_list)
stan_und_D           <- output$stan_fit
time_stan_und[[mtx]] <- output$time
```

\hfill

```{r}
smy_obj <- rstan::summary(stan_und_D, 
                          c("rho", str_glue("params[{1:n_params}]")))

sum_mtx <- smy_obj$summary %>% as.data.frame()
rownames(sum_mtx) <- c("rho", o_SEIR_D_und$params)
kable(sum_mtx[, c("mean", "sd", "n_eff", "Rhat")], booktab = TRUE)
```

```{r, fig.height = 2.5, fig.width = 5.5, fig.align = 'center'}
specs_list <- list(x_pos = 2.32, ypos_mean = 20, ypos_median = 17,
                   text_size = 2, ypos_interval = 14,
                   title = "Matrix D", xlabel = "")


summary_stan_und[[mtx]] <- summarise_results(stan_und_D, cm_list[[mtx]],
                                         und_df, 
                                         output_sp$population, specs_list, 
                                         o_SEIR_D_und$params, actual_K,
                                         scenario = "underreporting")

pred_K <- summary_stan_und[[mtx]]$summary_k$g_k_hat + 
  labs(subtitle = "Predicted K")

grid.arrange(pred_K, grey_actual_K, ncol = 2)
```

```{r}
summary_stan_und[[mtx]]$summary_k$g_pairs
```

```{r g_ts_stan_und_D, fig.height = 2.5, fig.align = 'center'}
summary_stan_und[[mtx]]$ts_summary$g_comparison
```
```{r, fig.height = 2.5, fig.width = 4, fig.align= 'center'}
summary_stan_und[[mtx]]$R_0$g
```

\newpage

#### Symmetric matrix

```{r stan_und_S}
mtx          <- "sym"
filename     <- str_glue("./Stan_files/Und_{mtx}.stan")

params_prior <- c("  params ~ normal(0, 10)", 
                  "  rho    ~ normal(0.5, 0.5)")

o_SEIR_sym_und <- write_SEIR_model(mtx, filename, output_gsi$stock_list, 
                                   params_prior, pop_size = pop_size, 
                                   "underreporting")

stan_d          <- stan_d_outline
n_params        <- length(unique(cm_list[[mtx]]))
stan_d$n_params <- n_params

seed             <- 1900039050
arg_list         <- arg_list_outline
arg_list$data    <- stan_d
arg_list$seed    <- seed
arg_list$data$y0 <- o_SEIR_sym_und$stock_inits

var_cache            <- TRUE
cache_file           <- str_glue("./object_fits/Stan/stan_fit_und_{mtx}.rds")
output               <- run_stan(filename, var_cache, cache_file, arg_list)
stan_und_sym         <- output$stan_fit
time_stan_und[[mtx]] <- output$time
```

\hfill

```{r}
smy_obj <- rstan::summary(stan_und_sym, 
                          c("rho", str_glue("params[{1:n_params}]")))

sum_mtx <- smy_obj$summary %>% as.data.frame()
rownames(sum_mtx) <- c("rho", o_SEIR_sym_und$params)
kable(sum_mtx[, c("mean", "sd", "n_eff", "Rhat")], booktab = TRUE)
```

```{r, fig.height = 2.5, fig.width = 5.5, fig.align = 'center'}
specs_list <- list(x_pos = 2.32, ypos_mean = 20, ypos_median = 17,
                   text_size = 2, ypos_interval = 14,
                   title = "Symmetric matrix", xlabel = "")


summary_stan_und[[mtx]] <- summarise_results(stan_und_sym, cm_list[[mtx]],
                                         und_df, 
                                         output_sp$population, specs_list, 
                                         o_SEIR_sym_und$params, actual_K,
                                         scenario = "underreporting")

pred_K <- summary_stan_und[[mtx]]$summary_k$g_k_hat + 
  labs(subtitle = "Predicted K")

grid.arrange(pred_K, grey_actual_K, ncol = 2)
```

```{r}
summary_stan_und[[mtx]]$summary_k$g_pairs
```

```{r g_ts_stan_und_sym, fig.height = 2.5, fig.align = 'center'}
summary_stan_und[[mtx]]$ts_summary$g_comparison
```
```{r, fig.height = 2.5, fig.width = 4, fig.align= 'center'}
summary_stan_und[[mtx]]$R_0$g
```

### Incidence goodness of fit

```{r errors_und_timeseries_optim}
MASEs <- purrr::map(summary_und_optim, "metrics") %>% 
  map_dbl("avg_MASE")

MSEs <- purrr::map(summary_und_optim, "metrics") %>% 
  map_dbl("avg_MSE")

errors_ts_optim_und <- data.frame(matrix = m_index,
                                  MASE = MASEs,
                                  MSE  = MSEs,
                                  method = "NMS",
                                  model = "Underreporting") %>% 
  mutate(is_min = ifelse(MASE == min(MASE), TRUE, FALSE))
```

```{r error_timeseries_stan_und}
MASEs <- purrr::map(summary_stan_und, "ts_summary") %>% 
  map_dbl("MASE")

MSEs <- purrr::map(summary_stan_und, "ts_summary") %>% 
  map_dbl("MSE")

errors_ts_stan_und <- data.frame(matrix = m_index,
                                 MASE = MASEs,
                                 MSE  = MSEs,
                                 method = "HMC",
                                 model = "Underreporting") %>% 
  mutate(is_min = ifelse(MASE == min(MASE), TRUE, FALSE))
```

```{r, fig.height = 3}
error_ts <- bind_rows(errors_ts_optim_und, errors_ts_stan_und)

ggplot(error_ts, aes(x = matrix, y = MASE)) +
  geom_lollipop(aes(colour = is_min)) +
  scale_colour_manual(values = c("grey", "steelblue")) +
  coord_flip() +
  geom_text(aes(label = round(MASE, 2)), nudge_y = 0.2, size = 3) +
  facet_wrap(~ method) +
  theme_test() +
  theme(legend.position = "none")

ggsave("./plots/incidence_fit_underreporting.pdf", dpi = "print", height = 3,
       width = 8)
```

### Likelihood

```{r}
log_liks <- purrr::map(summary_und_optim, "metrics") %>% 
  map_dbl("log_lik") 
  
log_liks_optim <- data.frame(matrix  = m_index,
                             log_lik = log_liks,
                             method  = "NMS") %>% 
  mutate(is_max = ifelse(log_lik == max(log_lik), TRUE, FALSE))
  
log_liks_optim <- data.frame(matrix  = m_index,
                             log_lik = log_liks,
                             method  = "NMS") %>% 
  mutate(is_max = ifelse(log_lik == max(log_lik), TRUE, FALSE))

log_liks <- purrr::map(summary_stan_und, "ts_summary") %>% 
  map_dbl("log_lik")

log_liks_stan <- data.frame(matrix  = m_index,
                             log_lik = log_liks,
                             method  = "HMC") %>% 
  mutate(is_max = ifelse(log_lik == max(log_lik), TRUE, FALSE))

log_liks_df <- bind_rows(log_liks_optim, log_liks_stan)

ggplot(log_liks_df , aes(x = matrix, y = log_lik)) +
  geom_point(aes(colour = is_max)) +
  scale_colour_manual(values = c("grey", "steelblue")) +
  coord_flip() +
  geom_text(aes(label = round(log_lik, 1), colour = is_max), 
            nudge_y = -65, size = 2) +
  facet_wrap(~ method, ncol = 1) +
  theme_test() +
  theme(legend.position = "none") +
  labs(y = "Log-likelihood",
       x = "Structure")
```

### Reporting value

```{r}
optim_rho <- map_dbl(summary_und_optim, "rho_hat")

rv_optim <- tibble(
  x = m_index,
  y = optim_rho,
  method = "NMS")

rv_stan  <- map_df(summary_stan_und, function(sum_stan) {
  rho_list <- sum_stan$rho_hat
  
  data.frame(y = rho_list$mean,
             lower.bound = rho_list$lower_bound,
             upper.bound = rho_list$upper_bound)
}) %>% mutate(x = m_index, method = "HMC")

df_rv <- bind_rows(rv_stan, rv_optim)
g_comparison_reporting_value <- draw_dcg(df_rv, c(0.4, 1), 0.8)

ggsave("./plots/comparison_reporting_value.pdf", dpi = "print", height = 3,
       width = 8)
print(g_comparison_reporting_value)
```

## $R_{0}$ estimation

```{r r_noughts}
R0_stan_prf <- map_df(summary_stan, consolidate_R0) %>% 
  mutate(matrix = m_index, method = "HMC", scenario = "Perfect information")

R0_stan_und <- map_df(summary_stan_und, consolidate_R0) %>% 
  mutate(matrix = m_index, method = "HMC", scenario = "Underreporting")

R0s <- map_dbl(summary_optim, "R_nought")

R_optim_prf <- data.frame(matrix   = m_index,
                          R0       = R0s,
                          method   = "NMS",
                          scenario = "Perfect information")

R0s <- map_dbl(summary_und_optim, "R_nought")

R_optim_und <- data.frame(matrix   = m_index,
                          R0       = R0s,
                          method   = "NMS",
                          scenario = "Underreporting")

R_nought_est <- bind_rows(R0_stan_prf, R0_stan_und, R_optim_prf, R_optim_und)

ggplot(R_nought_est, aes(x = matrix, y = R0)) +
  geom_point() +
  geom_errorbar(aes(ymin = lower.bound, ymax = upper.bound), width =.1) +
  geom_hline(yintercept = output_sp$theoretical_R0, linetype = "dashed") +
  scale_y_continuous(limits = c(2, 3.5)) +
  facet_grid(method ~ scenario) +
  theme_test() +
  theme(legend.text  = element_text(size = 3)) +
  labs(x = "Structure", y = bquote(R[0]))

ggsave("./plots/R0comparison.pdf", dpi = "print", height = 5,
       width = 8)
```

\newpage

## SMAPE in WAIFW's

```{r}
SMAPEs           <- map_dbl(summary_stan, extract_K_error) 
K_error_stan_prf <-data.frame(matrix   = m_index,
                              SMAPE    = SMAPEs,
                              method   = "HMC",
                              scenario = "Perfect information")

SMAPEs           <- map_dbl(summary_stan_und, extract_K_error)
K_error_stan_und <- data.frame(matrix   = m_index,
                               SMAPE    = SMAPEs,
                               method   = "HMC",
                                scenario = "Underreporting")

SMAPEs              <- map_dbl(summary_optim, "SMAPE_K")
K_error_optim_prf <- data.frame(matrix   = m_index,
                                SMAPE    = SMAPEs,
                                method   = "NMS",
                                scenario = "Perfect information")

SMAPEs            <- map_dbl(summary_und_optim, "SMAPE_K")
K_error_optim_und <- data.frame(matrix   = m_index,
                                SMAPE    = SMAPEs,
                                method   = "NMS",
                                scenario = "Underreporting")

K_error_list <- list(K_error_stan_prf, K_error_stan_und,
                     K_error_optim_prf, K_error_optim_und)

K_error_df <- map_df(K_error_list, function(df) {
  min_SMAPE <- min(df$SMAPE)
  df %>% mutate(is_min = SMAPE == min_SMAPE)
})

ggplot(K_error_df, aes(x = matrix, y = SMAPE)) +
  geom_lollipop(aes(colour = is_min)) +
  scale_y_continuous(limits = c(0, 10)) +
  coord_flip() +
  geom_text(aes(label = round(SMAPE, 2),
                colour = is_min), nudge_y = 1, size = 3) +
  scale_colour_manual(values = c("grey", "steelblue")) +
  facet_grid(scenario ~ method) +
  theme_test() +
  theme(legend.position = "none") +
  labs(x = "Structure")

ggsave("./plots/WAIFWcomparison.pdf", dpi = "print", height = 5,
       width = 8)
```

# Computational time

```{r}
times <- map_dbl(time_optim_pfr, calculate_time)
t1    <- data.frame(matrix = m_index, time = times, method = "NMS",
                    scenario = "Perfect information")


times <- map_dbl(time_optim_und, calculate_time)
t2    <- data.frame(matrix = m_index, time = times, method = "NMS",
                    scenario = "Underreporting")

times <- map_dbl(time_stan_pfr, calculate_time)
t3    <- data.frame(matrix = m_index, time = times, method = "HMC",
                    scenario = "Perfect information")

times <- map_dbl(time_stan_und, calculate_time)
t4    <- data.frame(matrix = m_index, time = times, method = "HMC",
                    scenario = "Underreporting")

t_df <- bind_rows(t1, t2, t3, t4)

g_time_comparison(t_df)
```


# Original Computing Environment

```{r}
sessionInfo()
```

